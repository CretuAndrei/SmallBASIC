Commands
----------------------------
Rem
Syntax:'|#|REM [remark]

Adds explanatory text to a program listing.'remark' commentary text,
ignored by BASIC.

The # can be used as remarks only if its in the first character of the
line.

Example:
' That text-line is just a few remarks
...
REM another comment
...
# one more comment
----------------------------
Let
Syntax:[LET] var = expr

Assigns the value of an expression to a variable.

var - A valid variable name.
expr - The value assigned to variable.

Example:
LET x = 4
x = 1 ' Without the LET keyword
z ="String data"' Assign string
...
DIM v(4)
z=v ' Assign array (z = clone of v)
----------------------------
Const
Syntax: CONST name = expr

Declares one constant.

name - An identifier that follows the rules for naming BASIC variables.

expr - An expression consisting of literals, with or without operators,
only.

Example:
COSNT G = 6.67259E-11
----------------------------
Dim
Syntax: DIM var([lower TO] upper [,...])[,...]

Creates an array of (upper-lower)+1 elements.
If the 'lower' is not specified, the arrays are starting from 0

Example:
REM One dimension array of 7 elements, starting from 0
DIM A(6)
...
REM One dimension array of 6 elements, starting from 1
DIM A(1 TO 6)
...
REM Three dimension array
DIM A(1 TO 6, 1 TO 4, 1 TO 8)
...
REM Allocating zero-length arrays:
DIM z()
...
IF LEN(Z)=0 THE APPEND Z,"The first element"
----------------------------
Label
Syntax:[LABEL] label

Defines a label. There are two kinds of labels. Numeric and
alphanumeric.

Numeric labels does not needed the keyword LABEL, but alphanumeric
does.

Example:
1000 ?"Hello"
...
LABEL AlphaLabel:?"Hello"
...
GOTO 1000
GOTO AlphaLabel
----------------------------
GoTo
Syntax: GOTO label

Causes program execution to branch to a specified position (label).
----------------------------
GoSub-Return

Syntax:
GOSUB label
.
.[commands]
.
RETURN

Causes program execution to branch to the specified label; when the
RETURN command is encountered, execution branches to the command
immediately following the most recent GOSUB command.
----------------------------
On-GoTo/On-GoSub

Syntax:
ON expr GOTO label1 [,... labelN]
ON expr GOSUB label1 [,... labelN]

Causes BASIC to branch to one of a list of labels.

expr - A numeric expression in the range 0 to 255. Upon execution of
the ON...GOTO command (or ON...GOSUB), BASIC branches to the nth
item in the list of labels that follows the keyword GOTO
(or GOSUB).
----------------------------
For-To-Step-Next

Syntax:
FOR counter = start TO end [STEP incr]
.
.[commands]
.
.[EXIT FOR]
.
NEXT

Begins the definition of a FOR/NEXT loop.

counter - A numeric variable to be used as the loop counter.

start - A numeric expression; the starting value of counter.

end - A numeric expression; the ending value of counter.

incr - A numeric expression; the value by which counter is
incremented or decremented with each iteration of the loop.
The default value is +1.

BASIC begins processing of the FOR/NEXT block by setting counter equal
to start. Then, if 'incr' is positive and counter is not greater than
end, the commands between the FOR and the NEXT are executed.

When the NEXT is encountered, counter is increased by 'incr', and the
process is repeated. Execution passes to the command following the NEXT
if counter is greater than end.

If increment is negative, execution of the FOR/NEXT loop is terminated
whenever counter becomes less than end.

FOR/NEXT loops may be nested to any level of complexity, but there
must be a NEXT for each FOR.

Example:
FOR C=1 TO 9
PRINT C
NEXT
----------------------------
For-In-Next
Syntax:
FOR element IN array
.
.[commands]
.
.[EXIT [FOR]]
.
NEXT

Begins the definition of a FOR/NEXT loop.

element - A variable to be used as the copy of the current element.

array - An array expression

The commands-block will repeated for LEN(array) times. Each time
the 'element' will holds the value of the current element of the array.

FOR/NEXT loops may be nested to any level of complexity, but there
must be a NEXT for each FOR.

Example:
A=[1,2,3]
FOR E IN A
PRINT E
NEXT
...
' This is the same with that
A=[1,2,3]
FOR I=LBOUND(A) TO UBOUND(A)
E=A(I)
PRINT E
NEXT
----------------------------
While-Wend
Syntax:
WHILE expression
.
.[commands]
.
.[EXIT [LOOP]]
.
WEND

Begins the definition of a WHILE/WEND loop.

expression - An expression

BASIC starts by evaluating expression. If expression is nonzero (true),
the next command is executed. If expression is zero (false), control
passes to the first command following the next WEND command.

When BASIC encounters the WEND command, it reevaluates the expression
parameter to the most recent WHILE. If that parameter is still nonzero
(true), the process is repeated; otherwise, execution continues at the
next command.

WHILE/WEND loops may be nested to any level of complexity, but there
must be a WEND for each WHILE.

Example:
C=1
WHILE C<10
PRINT C
C=C+1
WEND
...
' This is the same with that
FOR C=1 TO 9
PRINT C
NEXT
----------------------------
Repeat-Until
Syntax:
REPEAT
.
.[commands]
.
.[EXIT [LOOP]]
.
UNTIL expression

Begins the definition of a REPEAT/UNTIL loop.

expression - An expression

BASIC starts executing the commands between the REPEAT and UNTIL
commands. When BASIC encounters the UNTIL command, it evaluates the
expression parameter. If that parameter is zero (false), the process
will be repeated; otherwise, execution continues at the next command.

REPEAT/UNTIL loops may be nested to any level of complexity, but there
must be an UNTIL for each REPEAT.

Example:
C=1
REPEAT
PRINT C
C=C+1
UNTIL C=10
...
' This is the same with that
FOR C=1 TO 9
PRINT C
NEXT
----------------------------
If-Then-Else-ElIf-EndIf-FI

Syntax:
IF expression1 [THEN]
.
.[commands]
.
[[ELSEIF | ELIF] expression2 [THEN]
.
.[commands]
.
]
[ELSE
.
.[commands]
.
]
{ ENDIF | FI }

Block-style IF.

Causes BASIC to make a decision based on the value of an expression.

expression - An expression; 0 is equivalent to FALSE, while all
other values are equivalent to TRUE.

commands - One or more commands.

Each expression in the IF/ELSEIF construct is tested in order.
As soon as an expression is found to be TRUE, then its corresponding
commands are executed. If no expressions are TRUE, then the commands
following the ELSE keyword are executed. If ELSE is not specified, then
execution continues with the command following the ENDIF.

IF, ELSE, ELSEIF, and ENDIF must all be the first keywords on their
respective lines.

THEN is optional, but if its defined it must be the last keyword on its
line; if anything other than a comment follows on the same line with
THEN, BASIC thinks it's reading a single-line IF/THEN/ELSE construct.

IF blocks may be nested.

Example:
x=1
IF x=1 THEN
PRINT "true"
ELSE
PRINT "false"
ENDIF
...
' Alternate syntax:
x=1
IF x=1
PRINT "true"
ELSE
PRINT "false"
FI
----------------------------
Syntax:
' Single-line IF
IF expression THEN [num-label]|[command][ELSE [num-label]|[command]]

Single-line IF.

Causes BASIC to make a decision based on the value of an expression.

expression - An expression; 0 is equivalent to FALSE, while all
other values are equivalent to TRUE.

command - Any legal command or a numeric label. If a number is
specified, it is equivalent to a GOTO command with
the specified numeric-label.

Example:
' Single-line IF
x=1
IF x=1 THEN PRINT "true" ELSE PRINT "false"
...
IF x=1 THEN 1000
...
1000 PRINT "true"
----------------------------
If()
Syntax: IF(expression,true-value,false-value)

Returns a value based on the value of an expression.

Example:
x=0
PRINT IF(x<>0,"true","false"): REM prints false
----------------------------
End/Stop
Syntax:
STOP [error]
or
END [error]

Terminates execution of a program, closes all files opened by the
program, and returns control to the operating system.

error - A numeric expression.

The 'error' is the value which will returned to operating system;
if its not specified the BASIC will return 0.

Note:
The 'error' value is very well known as ERRORLEVEL value
on DOS/Windows systems
----------------------------
Restore
Syntax: RESTORE label

Specifies the position of the next data to be read.

label - A valid label.
----------------------------
Read
Syntax: READ var[, var ...]

Assigns values in DATA items to specified variables.

var - Any variable.

Unless a RESTORE command is executed, BASIC moves to the next DATA
item with each READ assignment. If BASIC runs out of DATA items to
READ, an run-time error occurs.

Example:
FOR c=1 TO 6
READ x
PRINT x
NEXT
...
DATA "a,b,c", 2
DATA 3, 4
DATA "fifth", 6
----------------------------
Data
Syntax: DATA constant1 [,constant2]...

Stores one or more constants, of any type, for subsequent access via
READ command.

DATA commands are nonexecutable statements that supply a stream of data
constants for use by READ commands. All the items supplied by all the
DATA commands in a program make up one continuous "string" of
information that is accessed in order by your program's READ commands.

Example:
RESTORE MyDataBlock
FOR I=1 TO 3
READ v
PRINT v
NEXT
END
...
LABEL MyDataBlock
DATA 1,2,3
----------------------------
Erase
Syntax: ERASE var[, var[,... var]]

var - Any variable.

Deallocates the memory used by the specified arrays or variables.
After that these variables turned to simple integers with zero value.

Example:
DIM x(100)
...
PRINT FRE(0)
ERASE x
PRINT FRE(0)
PRINT x(1):REM ERROR
----------------------------
Exit
Syntax: EXIT [FOR|LOOP|SUB|FUNC]

Exits a multiline function definition, a loop, or a subprogram.
By default (if no parameter is specified) exits from last command block
(loop, for-loop or routine).

FOR - Exit from the last FOR-NEXT loop
LOOP - Exit from the last WHILE-WEND or REPEAT-UNTIL loop
SUB - Return from the current routine
FUNC - Return from the current function
----------------------------
Len()
Syntax: LEN(x)

x - Any variable.

If x is a string, returns the length of the string.
If x is an array, returns the number of the elements.
If x is an number, returns the length of the STR(x).
----------------------------
Empty()
Syntax: EMPTY(x)

x - Any variable.

If x is a string, returns true if the len(x) is 0.
If x is an integer or a real returns true if the x = 0.
If x is an array, returns true if x is a zero-length array (array
without elements).
----------------------------
IsArray()
Syntax: ISARRAY(x)

x - Any variable.

Returns true if the x is an array.
----------------------------
IsNumber()
Syntax: ISNUMBER(x)

x - Any variable.

Returns true if the x is a number (or it can be converted to a number)

Example:
? ISNUMBER(12):REM true
? ISNUMBER("12"):REM true
? ISNUMBER("12E+2"):REM true
? ISNUMBER("abc"):REM false
? ISNUMBER("1+2"):REM false
? ISNUMBER("int(2.4)"):REM false
----------------------------
IsString()
Syntax: ISSTRING(x)

x - Any variable.

Returns true if the x is a string (and cannot be converted to a number)

Example:
? ISSTRING(12):REM false
? ISSTRING("12"):REM false
? ISSTRING("12E+2"):REM false
? ISSTRING("abc"):REM true
? ISSTRING("1+2"):REM true
----------------------------
Append
Syntax: APPEND A, val [, val [,...]]

A - An array-variable.

val - Any value or expression

Inserts the values at the end of the specified array.
----------------------------
Insert
Syntax: INSERT A, idx, val [, val [,...]]]

A - An array-variable.

idx - Position in the array.

val - Any value or expression.

Inserts the values to the specified array at the position idx.
----------------------------
Delete
Syntax: DELETE A, idx [, count]

A - An array-variable.

idx - Position in the array.

count - The number of the elements to be deleted.

Deletes 'count' elements at position 'idx' of array A
----------------------------
