char *help_page_b=
">> Commands\n"
"_______________________________________________________________________\n"
"\n"
"${key:rem}\n"
"'|#|REM [remark]\n"
"\n"
"Adds explanatory text to a program listing. 'remark' commentary text,\n"
"ignored by BASIC.\n"
"\n"
"The # can be used as remarks only if its in the first character of the\n"
"line.\n"
"\n"
"Example:\n"
"\n"
"' That text-line is just a few remarks\n"
"\n"
"REM another comment\n"
"\n"
"# one more comment\n"
"_______________________________________________________________________\n"
"\n"
"${key:let}\n"
"[LET] var = expr\n"
"\n"
"Assigns the value of an expression to a variable.\n"
"\n"
"var  - A valid variable name.\n"
"expr - The value assigned to variable.\n"
"\n"
"Example:\n"
"LET x = 4\n"
"x = 1               ' Without the LET keyword\n"
"z = \"String data\"   ' Assign string\n"
"\n"
"DIM v(4)\n"
"z=v                 ' Assign array (z = clone of v)\n"
"_______________________________________________________________________\n"
"\n"
"${key:const}\n"
"CONST name = expr\n"
"\n"
"Declares one constant.\n"
"\n"
"name - An identifier that follows the rules for naming BASIC variables.\n"
"\n"
"expr - An expression consisting of literals, with or without operators,\n"
"       only. \n"
"\n"
"Example:\n"
"\n"
"COSNT G = 6.67259E-11\n"
"_______________________________________________________________________\n"
"\n"
"${key:dim}\n"
"DIM var([lower TO] upper [, ...]) [, ...]\n"
"\n"
"Creates an array of (upper-lower)+1 elements.\n"
"If the 'lower' is not specified, the arrays are starting from 0\n"
"\n"
"Example: One dimension array of 7 elements, starting from 0\n"
"\n"
"DIM A(6)\n"
"\n"
"Example: One dimension array of 6 elements, starting from 1\n"
"\n"
"DIM A(1 TO 6)\n"
"\n"
"Example: Three dimension array\n"
"\n"
"DIM A(1 TO 6, 1 TO 4, 1 TO 8)\n"
"\n"
"Allocating zero-length arrays:\n"
"\n"
"DIM z()\n"
"\n"
"IF LEN(Z)=0 THE APPEND Z, \"The first element\"\n"
"_______________________________________________________________________\n"
"\n"
"${key:label}\n"
"[LABEL] label\n"
"\n"
"Defines a label. There are two kinds of labels. Numeric and \n"
"alphanumeric.\n"
"\n"
"Numeric labels does not needed the keyword LABEL, but alphanumeric\n"
"does.\n"
"\n"
"Example:\n"
"1000 ? \"Hello\"\n"
"\n"
"LABEL AlphaLabel: ? \"Hello\"\n"
"...\n"
"\n"
"GOTO 1000\n"
"GOTO AlphaLabel\n"
"_______________________________________________________________________\n"
"\n"
"${key:goto}\n"
"GOTO label\n"
"\n"
"Causes program execution to branch to a specified position (label).\n"
"_______________________________________________________________________\n"
"\n"
"${key:gosub}${key:return}\n"
"GOSUB label\n"
".\n"
". [commands]\n"
".\n"
"RETURN\n"
"\n"
"Causes program execution to branch to the specified label; when the \n"
"RETURN command is encountered, execution branches to the command \n"
"immediately following the most recent GOSUB command.\n"
"_______________________________________________________________________\n"
"\n"
"${key:on}${key:goto}${key:gosub}\n"
"ON expr GOTO label1 [, ... labelN]\n"
"ON expr GOSUB label1 [, ... labelN]\n"
"\n"
"Causes BASIC to branch to one of a list of labels.\n"
"\n"
"expr - A numeric expression in the range 0 to 255. Upon execution of\n"
"       the ON...GOTO command (or ON...GOSUB), BASIC branches to the nth\n"
"       item in the list of labels that follows the keyword GOTO \n"
"       (or GOSUB).\n"
"_______________________________________________________________________\n"
"\n"
"${key:for}${key:to}${key:step}${key:next}\n"
"FOR counter = start TO end [STEP incr]\n"
"    .\n"
"    . [commands]\n"
"    .\n"
"    . [EXIT FOR]\n"
"    .\n"
"NEXT\n"
"\n"
"Begins the definition of a FOR/NEXT loop.\n"
"\n"
"counter - A numeric variable to be used as the loop counter. \n"
"\n"
"start   - A numeric expression; the starting value of counter.\n"
"\n"
"end     - A numeric expression; the ending value of counter.\n"
"\n"
"incr    - A numeric expression; the value by which counter is\n"
"          incremented or decremented with each iteration of the loop.\n"
"          The default value is +1.\n"
"\n"
"BASIC begins processing of the FOR/NEXT block by setting counter equal\n"
"to start. Then, if 'incr' is positive and counter is not greater than\n"
"end, the commands between the FOR and the NEXT are executed.\n"
"\n"
"When the NEXT is encountered, counter is increased by 'incr', and the\n"
"process is repeated. Execution passes to the command following the NEXT\n"
"if counter is greater than end.\n"
"\n"
"If increment is negative, execution of the FOR/NEXT loop is terminated\n"
"whenever counter becomes less than end.\n"
"\n"
"FOR/NEXT loops may be nested to any level of complexity, but there\n"
"must be a NEXT for each FOR.\n"
"\n"
"Example:\n"
"\n"
"FOR C=1 TO 9\n"
"    PRINT C\n"
"NEXT\n"
"\n"
"_______________________________________________________________________\n"
"\n"
"${key:for}${key:in}\n"
"FOR element IN array\n"
"    .\n"
"    . [commands]\n"
"    .\n"
"    . [EXIT [FOR]]\n"
"    .\n"
"NEXT\n"
"\n"
"Begins the definition of a FOR/NEXT loop. \n"
"\n"
"element - A variable to be used as the copy of the current element. \n"
"\n"
"array   - An array expression\n"
"\n"
"The commands-block will repeated for LEN(array) times. Each time\n"
"the 'element' will holds the value of the current element of the array.\n"
"\n"
"FOR/NEXT loops may be nested to any level of complexity, but there\n"
"must be a NEXT for each FOR.\n"
"\n"
"Example:\n"
"\n"
"A=[1,2,3]\n"
"FOR E IN A\n"
"    PRINT E\n"
"NEXT\n"
"\n"
"' This is the same with that\n"
"\n"
"A=[1,2,3]\n"
"FOR I=LBOUND(A) TO UBOUND(A)\n"
"    E=A(I)\n"
"    PRINT E\n"
"NEXT\n"
"\n"
"_______________________________________________________________________\n"
"\n"
"${key:while}${key:wend}\n"
"WHILE expression\n"
"    .\n"
"    . [commands]\n"
"    .\n"
"    . [EXIT [LOOP]]\n"
"    .\n"
"WEND\n"
"\n"
"Begins the definition of a WHILE/WEND loop.\n"
"\n"
"expression - An expression\n"
"\n"
"BASIC starts by evaluating expression. If expression is nonzero (true),\n"
"the next command is executed. If expression is zero (false), control\n"
"passes to the first command following the next WEND command.\n"
"\n"
"When BASIC encounters the WEND command, it reevaluates the expression\n"
"parameter to the most recent WHILE. If that parameter is still nonzero\n"
"(true), the process is repeated; otherwise, execution continues at the\n"
"next command.\n"
"\n"
"WHILE/WEND loops may be nested to any level of complexity, but there\n"
"must be a WEND for each WHILE.\n"
"\n"
"Example:\n"
"\n"
"C=1\n"
"WHILE C<10\n"
"    PRINT C\n"
"    C=C+1\n"
"WEND\n"
"\n"
"' This is the same with that\n"
"\n"
"FOR C=1 TO 9\n"
"    PRINT C\n"
"NEXT\n"
"_______________________________________________________________________\n"
"\n"
"${key:repeat}${key:until}\n"
"REPEAT\n"
"    .\n"
"    . [commands]\n"
"    .\n"
"    . [EXIT [LOOP]]\n"
"    .\n"
"UNTIL expression\n"
"\n"
"Begins the definition of a REPEAT/UNTIL loop.\n"
"\n"
"expression - An expression\n"
"\n"
"BASIC starts executing the commands between the REPEAT and UNTIL\n"
"commands. When BASIC encounters the UNTIL command, it evaluates the\n"
"expression parameter. If that parameter is zero (false), the process\n"
"will be repeated; otherwise, execution continues at the next command.\n"
"\n"
"REPEAT/UNTIL loops may be nested to any level of complexity, but there\n"
"must be an UNTIL for each REPEAT.\n"
"\n"
"Example:\n"
"\n"
"Example:\n"
"\n"
"C=1\n"
"REPEAT\n"
"    PRINT C\n"
"    C=C+1\n"
"UNTIL C=10\n"
"\n"
"' This is the same with that\n"
"\n"
"FOR C=1 TO 9\n"
"    PRINT C\n"
"NEXT\n"
"_______________________________________________________________________\n"
"\n"
"${key:if}${key:then}${key:else}${key:elif}${key:endif}${key:fi}\n"
"IF expression1 [THEN]\n"
"    .\n"
"    . [commands]\n"
"    .\n"
"[ [ELSEIF | ELIF] expression2 [THEN]\n"
"    .\n"
"    . [commands]\n"
"    .\n"
"]\n"
"[ELSE\n"
"    .\n"
"    . [commands]\n"
"    .\n"
"]\n"
"{ ENDIF | FI }\n"
"\n"
"Block-style IF.\n"
"\n"
"Causes BASIC to make a decision based on the value of an expression.\n"
"\n"
"expression - An expression; 0 is equivalent to FALSE, while all\n"
"             other values are equivalent to TRUE.\n"
"\n"
"commands   - One or more commands.\n"
"\n"
"Each expression in the IF/ELSEIF construct is tested in order.  \n"
"As soon as an expression is found to be TRUE, then its corresponding\n"
"commands are executed. If no expressions are TRUE, then the commands\n"
"following the ELSE keyword are executed. If ELSE is not specified, then\n"
"execution continues with the command following the ENDIF.\n"
"\n"
"IF, ELSE, ELSEIF, and ENDIF must all be the first keywords on their\n"
"respective lines.\n"
"\n"
"THEN is optional, but if its defined it must be the last keyword on its\n"
"line; if anything other than a comment follows on the same line with\n"
"THEN, BASIC thinks it's reading a single-line IF/THEN/ELSE construct.\n"
"\n"
"IF blocks may be nested.\n"
"\n"
"Example:\n"
"\n"
"x=1\n"
"IF x=1 THEN\n"
"    PRINT \"true\"\n"
"ELSE\n"
"    PRINT \"false\"\n"
"ENDIF\n"
"\n"
"' Alternate syntax:\n"
"\n"
"x=1\n"
"IF x=1\n"
"    PRINT \"true\"\n"
"ELSE\n"
"    PRINT \"false\"\n"
"FI\n"
"_______________________________________________________________________\n"
"\n"
"IF expression THEN [num-label]|[command] [ELSE [num-label]|[command]]\n"
"\n"
"Single-line IF.\n"
"\n"
"Causes BASIC to make a decision based on the value of an expression.\n"
"\n"
"expression - An expression; 0 is equivalent to FALSE, while all\n"
"             other values are equivalent to TRUE.\n"
"\n"
"command    - Any legal command or a numeric label. If a number is\n"
"             specified, it is equivalent to a GOTO command with\n"
"             the specified numeric-label.\n"
"\n"
"Example:\n"
"\n"
"x=1\n"
"IF x=1 THEN PRINT \"true\" ELSE PRINT \"false\"\n"
"...\n"
"IF x=1 THEN 1000\n"
"...\n"
"1000 PRINT \"true\"\n"
"_______________________________________________________________________\n"
"\n"
"${key:if}\n"
"IF(expression,true-value,false-value)\n"
"\n"
"Returns a value based on the value of an expression.\n"
"\n"
"Example:\n"
"\n"
"x=0\n"
"PRINT IF(x<>0,\"true\",\"false\") : REM prints false\n"
"_______________________________________________________________________\n"
"\n"
"${key:stop}${key:end}\n"
"STOP [error]\n"
"or\n"
"END [error]\n"
"\n"
"Terminates execution of a program, closes all files opened by the\n"
"program, and returns control to the operating system.\n"
"\n"
"error - A numeric expression.\n"
"\n"
"The 'error' is the value which will returned to operating system;\n"
"if its not specified the BASIC will return 0.\n"
"\n"
"Note:\n"
"  The 'error' value is very well known as ERRORLEVEL value \n"
"  on DOS/Windows systems\n"
"_______________________________________________________________________\n"
"\n"
"${key:restore}\n"
"RESTORE label\n"
"\n"
"Specifies the position of the next data to be read.\n"
"\n"
"label - A valid label.\n"
"_______________________________________________________________________\n"
"\n"
"${key:read}\n"
"READ var[, var ...]\n"
"\n"
"Assigns values in DATA items to specified variables.\n"
"\n"
"var - Any variable.\n"
"\n"
"Unless a RESTORE command is executed, BASIC moves to the next DATA\n"
"item with each READ assignment. If BASIC runs out of DATA items to\n"
"READ, an run-time error occurs.\n"
"\n"
"Example:\n"
"\n"
"FOR c=1 TO 6\n"
"    READ x\n"
"    PRINT x\n"
"NEXT\n"
"\n"
"DATA \"a,b,c\", 2\n"
"DATA 3, 4\n"
"DATA \"fifth\", 6\n"
"\n"
"_______________________________________________________________________\n"
"\n"
"${key:data}\n"
"DATA constant1 [,constant2]...\n"
"\n"
"Stores one or more constants, of any type, for subsequent access via\n"
"READ command.\n"
"\n"
"DATA commands are nonexecutable statements that supply a stream of data\n"
"constants for use by READ commands. All the items supplied by all the\n"
"DATA commands in a program make up one continuous \"string\" of\n"
"information that is accessed in order by your program's READ commands.\n"
"\n"
"Example:\n"
"\n"
"RESTORE MyDataBlock\n"
"FOR I=1 TO 3\n"
"    READ v\n"
"    PRINT v\n"
"NEXT\n"
"END\n"
"\n"
"LABEL MyDataBlock\n"
"DATA 1,2,3\n"
"_______________________________________________________________________\n"
"\n"
"${key:erase}\n"
"ERASE var[, var[, ... var]]\n"
"\n"
"var - Any variable.\n"
"\n"
"Deallocates the memory used by the specified arrays or variables. \n"
"After that these variables turned to simple integers with zero value.\n"
"\n"
"Example:\n"
"\n"
"DIM x(100)\n"
"...\n"
"PRINT FRE(0)\n"
"ERASE x\n"
"PRINT FRE(0)\n"
"PRINT x(1):REM ERROR\n"
"_______________________________________________________________________\n"
"\n"
"${key:exit}\n"
"EXIT [FOR|LOOP|SUB|FUNC]\n"
"\n"
"Exits a multiline function definition, a loop, or a subprogram.\n"
"By default (if no parameter is specified) exits from last command block\n"
"(loop, for-loop or routine).\n"
"\n"
"FOR     - Exit from the last FOR-NEXT loop\n"
"LOOP    - Exit from the last WHILE-WEND or REPEAT-UNTIL loop\n"
"SUB     - Return from the current routine\n"
"FUNC    - Return from the current function\n"
"_______________________________________________________________________\n"
"\n"
"${key:len}\n"
"LEN(x)\n"
"\n"
"x - Any variable.\n"
"\n"
"If x is a string, returns the length of the string.\n"
"If x is an array, returns the number of the elements.\n"
"If x is an number, returns the length of the STR(x).\n"
"_______________________________________________________________________\n"
"\n"
"${key:empty}\n"
"EMPTY(x)\n"
"\n"
"x - Any variable.\n"
"\n"
"If x is a string, returns true if the len(x) is 0.\n"
"If x is an integer or a real returns true if the x = 0.\n"
"If x is an array, returns true if x is a zero-length array (array\n"
"without elements).\n"
"_______________________________________________________________________\n"
"\n"
"${key:isarray}\n"
"ISARRAY(x)\n"
"\n"
"x - Any variable.\n"
"\n"
"Returns true if the x is an array.\n"
"_______________________________________________________________________\n"
"\n"
"${key:isnumber}\n"
"ISNUMBER(x)\n"
"\n"
"x - Any variable.\n"
"\n"
"Returns true if the x is a number (or it can be converted to a number)\n"
"\n"
"Example:\n"
"? ISNUMBER(12)          :REM true\n"
"? ISNUMBER(\"12\")        :REM true\n"
"? ISNUMBER(\"12E+2\")     :REM true\n"
"? ISNUMBER(\"abc\")       :REM false\n"
"? ISNUMBER(\"1+2\")       :REM false\n"
"? ISNUMBER(\"int(2.4)\")  :REM false\n"
"_______________________________________________________________________\n"
"\n"
"${key:isstring}\n"
"ISSTRING(x)\n"
"\n"
"x - Any variable.\n"
"\n"
"Returns true if the x is a string (and cannot be converted to a number)\n"
"\n"
"Example:\n"
"? ISSTRING(12)      :REM false\n"
"? ISSTRING(\"12\")    :REM false\n"
"? ISSTRING(\"12E+2\") :REM false\n"
"? ISSTRING(\"abc\")   :REM true\n"
"? ISSTRING(\"1+2\")   :REM true\n"
"_______________________________________________________________________\n"
"\n"
"${key:append}\n"
"APPEND A, val [, val [, ...]]\n"
"\n"
"A   - An array-variable.\n"
"\n"
"val - Any value or expression\n"
"\n"
"Inserts the values at the end of the specified array.\n"
"_______________________________________________________________________\n"
"\n"
"${key:insert}\n"
"INSERT A, idx, val [, val [, ...]]]\n"
"\n"
"A   - An array-variable.\n"
"\n"
"idx - Position in the array.\n"
"\n"
"val - Any value or expression.\n"
"\n"
"Inserts the values to the specified array at the position idx.\n"
"_______________________________________________________________________\n"
"\n"
"${key:delete}\n"
"DELETE A, idx [, count]\n"
"\n"
"A       - An array-variable.\n"
"\n"
"idx     - Position in the array.\n"
"\n"
"count   - The number of the elements to be deleted.\n"
"\n"
"Deletes 'count' elements at position 'idx' of array A\n"
"\n"
"_______________________________________________________________________\n"
"\n"
;