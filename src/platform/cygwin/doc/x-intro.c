char *help_page_a=
">> Useful notes for beginners\n"
"_______________________________________________________________________\n"
"\n"
"How to read the syntax:\n"
"\n"
"Everything is written inside of [] characters are optional values.\n"
"Everything is written inside of {} characters means you must select one\n"
"of them.\n"
"The symbol | means OR.\n"
"The symbols ... means you can repeat the previous syntax.\n"
"The keywords are written with capital letters.\n"
"\n"
"Examples:\n"
"Syntax: TEST {1|2}\n"
"\n"
"Valid calls:\n"
"TEST 1\n"
"TEST 2\n"
"\n"
"Syntax: TEST [HI]\n"
"\n"
"Valid calls:\n"
"TEST\n"
"TEST HI\n"
"\n"
"\n"
">> Limits\n"
"_______________________________________________________________________\n"
"\n"
"Bytecode size:                    4 GB\n"
"Length of text lines:          4095 characters\n"
"User-defined keyword length:     32 characters\n"
"Maximum number of parameters:   256\n"
"Numeric value range:             64 bit FPN (-/+ 1E+308)\n"
"Maximum string size:              2 GB\n"
"Number of file handles:         256\n"
"Number of array-dimensions:       6\n"
"Number of colors:                24 bit (0-15=VGA, <0=RGB)\n"
"Background sound queue size:    256 notes\n"
"INPUT (console): 1023 characters per call, up to 16 variables\n"
"COMMAND$                       1023 bytes\n"
"\n"
"System events are checked every 50ms\n"
"\n"
"=== PalmOS only (or other limited OS):\n"
"Length of text lines:           511 characters\n"
"Maximum number of parameters:    32\n"
"Number of array-dimensions:       3\n"
"Maximum string size:            <32 KB\n"
"Number of file handles:          16\n"
"Number of elements/array:      2970 (that means 64KB of memory)\n"
"Bytecode size:                  <64 KB\n"
"                      (by using CHAIN you can run progs > 64KB)\n"
"INPUT (console): 255 characters per call, up to 16 variables\n"
"COMMAND$                        127 bytes\n"
"\n"
"\n"
">> Constants and Variables\n"
"_______________________________________________________________________\n"
"\n"
"SmallBASIC uses internally 4 data-types\n"
"1. Integer  (32bit)\n"
"2. Real     (64bit)\n"
"3. String   (<32KB on 16bit / 2GB on 32bit)\n"
"4. Array    (~2970 elements on 16bit / ~50M elements on 32bit)\n"
"\n"
"Reals can be also written by using scientific notation.\n"
"1E+2, 1E-3, 2.6E-0.25, etc\n"
"\n"
"All user variables (include arrays) are 'VARIANT'. That means the \n"
"data-type is invisible to user.\n"
"\n"
"Variable names can use any alphanumeric characters, extended\n"
"characters (ASCII codes 128-255 for non-English languages) the symbol\n"
"'_', and the symbol '$'.\n"
"\n"
"The first character of the name cannot be a digit nor a '$'.\n"
"\n"
"About the dollar-symbol:\n"
"The symbol '$' is supported for compatibility.\n"
"Since in SmallBASIC there are no data-types its use is meaningless.\n"
"\n"
"The dollar in function names will be ignored\n"
"The dollar in variable names will be count as part of the name\n"
"(that means v and v$ are two different variables)\n"
"The dollar in system variables names will be ignore it\n"
"(that means COMMAND and COMMAND$ is the same)\n"
"\n"
"Example:\n"
"abc, a_c, _bc, ab2c, abc$ -> valid names\n"
"1cd, a$b, $abc            -> invalid names\n"
"\n"
"Strings may be appended to one another using the + operator.\n"
"\n"
"b = \"Hello, \" + \"world!\"\n"
"\n"
"Constant variables can be declared by using the keyword CONST\n"
"\n"
" CONST ð = 3.14\n"
"\n"
"\n"
"${key:osname}${key:osver}${key:sbver}${key:pi}${key:xmax}${key:ymax}${key:bpp}${key:vidadr}${key:cwd}${key:home}${key:command}\n"
">> System Variables\n"
"_______________________________________________________________________\n"
"\n"
"OSNAME      - Operating System name\n"
"OSVER       - Operating System Version (0xAABBCC\n"
"              (A=major, B=minor, C=patch)\n"
"SBVER       - SmallBASIC Version (0xAABBCC)\n"
"\n"
"PI          - 3.14..\n"
"\n"
"XMAX,YMAX   - Graphics display: maximum x (width-1), y (height-1) value\n"
"BPP         - Graphics display: bits per pixel (color resolution)\n"
"VIDADR      - Video RAM address (only on specific drivers)\n"
"\n"
"CWD         - Current Working Directory\n"
"HOME        - User's directory\n"
"COMMAND     - Command-line parameters\n"
"\n"
"TRUE        - The value 1\n"
"FALSE       - The value 0\n"
"\n"
"\n"
"${key:operators}${key:and}${key:or}${key:band}${key:bor}${key:eqv}${key:imp}${key:xor}${key:nor}${key:nand}${key:xnor}${key:mod}${key:mdl}${key:not}\n"
">> Operators (by priority):\n"
"_______________________________________________________________________\n"
"\n"
"( )          Parenthesis\n"
"\n"
"+, -         Unary\n"
"~            bitwise NOT\n"
"NOT or !     Logical NOT  (NOT false = true)\n"
"\n"
"^            Exponentiation\n"
"\n"
"*, /, \\      Multiplication, Division, Integer Division\n"
"% or MOD     Reminder (like QB's; a=int(a), b=int(b), a-b*(a/b))\n"
"MDL          Modulus  (a%b+b*(sgn(a)<>sgn(b)))\n"
"\n"
"+, -         Addition/Concatenation, Subtraction\n"
"\n"
"=            Equal\n"
"<> or !=     Not Equal\n"
">,    <      Less Than, Greater Than\n"
"=>,   =<     Less or Equal, Greater or Equal\n"
">=,   <=     Less or Equal, Greater or Equal\n"
"IN           see \"The IN operator\"\n"
"LIKE         see \"The LIKE operator\"\n"
"\n"
"AND or &&    Logical AND  \n"
"OR  or ||    Logical OR\n"
"BAND or &    bitwise AND\n"
"BOR  or |    bitwise OR\n"
"EQV          bitwise EQV\n"
"IMP          bitwise IMP\n"
"XOR          bitwise XOR\n"
"NAND         bitwise NAND\n"
"NOR          bitwise NOR\n"
"XNOR         bitwise XNOR\n"
"\n"
"\n"
">> Special Characters\n"
"_______________________________________________________________________\n"
"\n"
"&h or 0x    Prefix for hexadecimal constant (0x1F,   &h3C)\n"
"&o or 0o    Prefix for octal constant       (0o33,   &o33)\n"
"&b or 0b    Prefix for binary constant      (0b1010, &b1110)\n"
"\n"
"[,;]        Array definition (function ARRAY())                    ($1)\n"
"\n"
"<<          Appends to an array (command APPEND)                   ($1)\n"
"\n"
"++          Increase a value by 1 (x = x + 1)                      ($1)\n"
"\n"
"--          Decrease a value by 1 (x = x - 1)                      ($1)\n"
"\n"
"p=          Another LET macro (x = x p ...)                        ($1)\n"
"            Where p any character of -+/\\*^%&|\n"
"\n"
":           Separates commands typed on the same line\n"
"\n"
"&           Join code lines (if its the last character of the line)\n"
"            The result line its must not exceed the max. line size.\n"
"\n"
"#           Meta-command (if its the first character of the line)\n"
"            or prefix for file handle\n"
"\n"
"@           The 'at' symbol can by used instead of BYREF          ($1)\n"
"\n"
"'           Remarks\n"
"\n"
"Notes:\n"
"($1) = Pseudo operators. These operators are replaced by compiler with\n"
"a command or an expression.\n"
"\n"
"\n"
"${key:option}${key:base}${key:predef}\n"
">> The OPTION keyword\n"
"_______________________________________________________________________\n"
"\n"
"OPTION keyword parameters\n"
"\n"
"This special command is used to pass parameters to the SB-environment.\n"
"There are two styles for that, the run-time (like BASE) which can\n"
"change the value at run-time, and the compile-time (like PREDEF)\n"
"which used only in compile-time and the value cannot be changed\n"
"on run-time.\n"
"\n"
"Keyword: BASE (run-time)\n"
"\n"
"    OPTION BASE lower-bound\n"
"\n"
"    Sets the default lower bound for arrays.\n"
"\n"
"Keyword: PREDEF (compile-time)\n"
"\n"
"    OPTION PREDEF {QUITE|COMMAND cmdstr|GRMODE}\n"
"\n"
"    Sets parameters of the compiler\n"
"\n"
"        QUITE\n"
"        sets quite flag (-q option)\n"
"\n"
"        COMMAND cmdstr\n"
"        sets the COMMAND$ string (useful for debug reasons)\n"
"\n"
"        GRMODE [WIDTHxHEIGHT[xBPP]]\n"
"        sets the graphics mode flag (-g option)\n"
"        or sets the prefered screen resolution.\n"
"\n"
"        Example: (Clie HiRes)\n"
"            OPTION PREDEF GRMODE 320x320x16\n"
"\n"
"        TEXTMODE\n"
"        sets the text mode flag (-g- option)\n"
"\n"
"        CSTR\n"
"        support c-style special character encoding ('\\')\n"
"\n"
"\n"
">> Meta-commands:\n"
"_______________________________________________________________________\n"
"\n"
"#!...       \n"
"Used by Unix to make source runs as a script executable\n"
"\n"
"#sec:section name\n"
"Used internally to store the section name. DO NOT USE IT!\n"
"\n"
"#inc:\"file\"\n"
"or\n"
"#inc:file\n"
"Used to include a SmallBASIC source file into the current BASIC code\n"
"\n"
"Example:\n"
"...\n"
"#inc:\"mylib.bas\"\n"
"...\n"
"MyLibProc \"Hi\"\n"
"\n"
"\n"
">> Arrays and Matrices\n"
"_______________________________________________________________________\n"
"\n"
"Define a 3x2 matrix\n"
"\n"
"A = [11, 12; 21, 22; 31, 32]\n"
"\n"
"That creates the array\n"
"\n"
"| 11  12 |\n"
"| 21  22 | = A\n"
"| 31  32 |\n"
"\n"
"The comma used to separate column items; the semi-colon used to \n"
"separate rows. Values between columns can be omitted.\n"
"\n"
"Example:\n"
"\n"
"A = [ ; ; 1, 2 ; 3, 4, 5]\n"
"\n"
"This creates the array\n"
"\n"
"| 0  0  0 |\n"
"| 1  2  0 | = A\n"
"| 3  4  5 |\n"
"\n"
"Supported operators:\n"
"\n"
"Add/sub:\n"
"B = [1, 2; 3, 4]: C = [5, 6; 7, 8]\n"
"\n"
"A = B + C\n"
"C = A - B\n"
"\n"
"Equal: \n"
"bool=(A=B)\n"
"\n"
"Unary:\n"
"A2 = -A\n"
"\n"
"Multiplication:\n"
"\n"
"A = [1, 2; 3, 4]: B = [5 ; 6]\n"
"C = A * B\n"
"D = 0.8 * A\n"
"\n"
"Inverse:\n"
"A = [ 1, -1, 1; 2, -1, 2; 3, 2, -1]\n"
"? INVERSE(A)\n"
"\n"
"Gauss-Jordan:\n"
"\n"
"? \"Solve this:\"\n"
"? \"  5x - 2y + 3z = -2\"\n"
"? \" -2x + 7y + 5z =  7\"\n"
"? \"  3x + 5y + 6z =  9\"\n"
"?\n"
"A = [ 5, -2, 3; -2, 7, 5; 3, 5, 6]\n"
"B = [ -2; 7; 9]\n"
"C = LinEqn(A, B)\n"
"? \"[x;y;z] = \"; C\n"
"\n"
"Note:\n"
"There is a problem with 1 dimension arrays, because 1-dim arrays does\n"
"not specify how SmallBASIC must see them.\n"
"\n"
"Example:\n"
"DIM A(3)\n"
"\n"
"| 1 2 3 | = A\n"
"\n"
"or\n"
"\n"
"| 1 |\n"
"| 2 | = A\n"
"| 3 |\n"
"\n"
"And because this is not the same thing. (ex. for multiplication)\n"
"\n"
"So the default is columns\n"
"\n"
"DIM A(3) ' or A(1,3)\n"
"\n"
"| 1 2 3 | = A\n"
"\n"
"For vertical arrays you must declare it as 2-dim arrays Nx1\n"
"\n"
"DIM A(3,1)\n"
"\n"
"| 1 |\n"
"| 2 | = A\n"
"| 3 |\n"
"\n"
"\n"
">> Nested arrays\n"
"_______________________________________________________________________\n"
"\n"
"Nested arrays are allowed\n"
"\n"
"Example:\n"
"\n"
"A = [[1,2] , [3,4]]\n"
"B = [1, 2, 3]\n"
"C = [4, 5]\n"
"B(2) = C\n"
"print B\n"
"\n"
"This will be printed\n"
"[1, 2, [4, 5], 3]\n"
"\n"
"You can access them by using a second (or third, etc) pair of\n"
"parenthesis.\n"
"\n"
"B(2)(1) = 16\n"
"print B(2)(1)\n"
"\n"
"Result:\n"
"    16\n"
"\n"
"\n"
"${key:in}\n"
">> The operator IN\n"
"_______________________________________________________________________\n"
"\n"
"IN operator is used to compare if the left-expression belongs to \n"
"right-expression\n"
"\n"
"' Using it with arrays\n"
"print 1 in [2,3]        :REM FALSE\n"
"print 1 in [1,2]        :REM TRUE\n"
"\n"
"' Using it with strings\n"
"print \"na\" in \"abcde\"   :REM FALSE\n"
"print \"cd\" in \"abcde\"   :REM TRUE\n"
"\n"
"' Using it with number (true only if left = right)\n"
"print 11 in 21          :REM FALSE\n"
"print 11 in 11          :REM TRUE\n"
"\n"
"' special case\n"
"' auto-convert integers/reals\n"
"print 12 in \"234567\"    :REM FALSE\n"
"print 12 in \"341256\"    :REM TRUE\n"
"\n"
"\n"
"${key:like}\n"
">> The operator LIKE\n"
"_______________________________________________________________________\n"
"\n"
"LIKE is a regular-expression operator.\n"
"It is compares the left part of the expression with the pattern (right\n"
"part).\n"
"Since the original regular expression code is too big (for handhelds),\n"
"I use only a subset of it, based on an excellent old stuff by \n"
"J. Kercheval (match.c, public-domain, 1991).\n"
"The same code is used for filenames (FILES(), DIRWALK)\n"
"\n"
"In the pattern string:\n"
"*      matches any sequence of characters (zero or more)\n"
"?      matches any character\n"
"[SET]  matches any character in the specified set,\n"
"[!SET] or [^SET] matches any character not in the specified set.\n"
"\n"
"A set is composed of characters or ranges; a range looks like\n"
"character hyphen character (as in 0-9 or A-Z). [0-9a-zA-Z_] is the\n"
"minimal set of characters allowed in the [..] pattern construct.\n"
"\n"
"To suppress the special syntactic significance of any of `[]*?!^-\\',\n"
"and match the character exactly, precede it with a `\\'.\n"
"\n"
"Examples:\n"
"\n"
"? \"Hello\" LIKE \"*[oO]\" : REM TRUE\n"
"? \"Hello\" LIKE \"He??o\" : REM TRUE\n"
"? \"Hello\" LIKE \"hello\" : REM FALSE\n"
"? \"Hello\" LIKE \"[Hh]*\" : REM TRUE\n"
"\n"
"\n"
">> The pseudo-operator <<\n"
"_______________________________________________________________________\n"
"\n"
"This operator can be used to append elements to an array.\n"
"\n"
"A << 1\n"
"A << 2\n"
"A << 3\n"
"\n"
"? A(1)\n"
"\n"
"\n"
"${key:sub}${key:func}${key:def}${key:local}${key:byref}\n"
">> Subroutines and Functions\n"
"_______________________________________________________________________\n"
"\n"
"SUB name [([BYREF] par1 [, ...[BYREF] parN)]]\n"
"  [LOCAL var[, var[, ...]]]\n"
"  [EXIT SUB]\n"
"  ...\n"
"END\n"
"\n"
"FUNC name[([BYREF] par1 [, ...[BYREF] parN)]]\n"
"  [LOCAL var[, var[, ...]]]\n"
"  [EXIT FUNC]\n"
"\n"
"  name=return-value\n"
"END\n"
"\n"
"Use function's name to return the value.\n"
"\n"
"Alternative FUNC/DEF syntax (single-line functions)\n"
"This is a macro for compatibility with the BASIC's DEF FN command.\n"
"\n"
"FUNC name[(par1[,...])] = expression\n"
"or\n"
"DEF name[(par1[,...])] = expression\n"
"\n"
"Example:\n"
"\n"
"DEF FNSin(x) = SIN(x)\n"
"\n"
"? FNSin(pi/2)\n"
"\n"
"\n"
"Nested procedures/functions are allowed (like Pascal).\n"
"\n"
"Example:\n"
"\n"
"FUNC f(x)\n"
"    FUNC f1(x)\n"
"        FUNC f2(x)\n"
"            f2=cos(x)\n"
"        END\n"
"        f1 = f2(x)/4\n"
"    END\n"
"\n"
"    FUNC f3\n"
"        f3=f1(pi/2)\n"
"    END\n"
"\n"
"? f1(pi) : REM OK\n"
"? f2(pi) : REM ERROR\n"
"f = x + f1(pi) + f3 : REM OK\n"
"END\n"
"\n"
"The parameters are 'by value' by default.\n"
"Passing parameters by value means the executor makes a copy of the\n"
"parameter to stack. The value in caller's code will not be changed.\n"
"\n"
"Use BYREF keyword for passing parameters 'by reference'. \n"
"Passing parameters by reference means the executor push the pointer\n"
"of variable into the stack. The value in caller's code will be the\n"
"changed.\n"
"\n"
"Example:\n"
"\n"
"' Passing 'x' by value\n"
"SUB F(x)\n"
"  x=1\n"
"END\n"
"\n"
"x=2\n"
"F x\n"
"? x:REM displays 2\n"
"____________________________\n"
"\n"
"' Passing 'x' by reference\n"
"SUB F(BYREF x)\n"
"  x=1\n"
"END\n"
"\n"
"x=2\n"
"F x\n"
"? x:REM displays 1\n"
"\n"
"You can use the symbol '@' instead of BYREF. There is no\n"
"difference between @ and BYREF.\n"
"\n"
"SUB F(@x)\n"
"  x=1\n"
"END\n"
"\n"
"On a multi-section applications sub/funcs needs declaration on the main\n"
"section.\n"
"\n"
"Example:\n"
"#sec:Main\n"
"declare func f(x)\n"
"\n"
"#sec:another section\n"
"func f(x)\n"
"...\n"
"end\n"
"\n"
"Use the LOCAL keyword for local variables.\n"
"LOCAL creates variables (dynamic) at routine's code.\n"
"\n"
"Example:\n"
"\n"
"SUB MYPROC\n"
"  LOCAL N:REM LOCAL VAR\n"
"  N=2\n"
"  ? N:REM displays 2\n"
"END\n"
"\n"
"N=1:REM GLOBAL VAR\n"
"MYPROC\n"
"? N:REM displays 1\n"
"\n"
"You can send arrays as parameters.\n"
"\n"
"When using arrays as parameters its better to use them as BYREF;\n"
"otherwise their data will be duplicated.\n"
"\n"
"Example:\n"
"SUB FBR(BYREF tbl)\n"
"  ? FRE(0)\n"
"  ...\n"
"END\n"
"\n"
"SUB FBV(tbl)\n"
"  ? FRE(0)\n"
"  ...\n"
"END\n"
"\n"
"' MAIN\n"
"DIM dt(128)\n"
"...\n"
"? FRE(0)\n"
"FBR dt\n"
"? FRE(0)\n"
"FBV dt\n"
"? FRE(0)\n"
"\n"
"Passing & returning arrays, using local arrays.\n"
"\n"
"Example:\n"
"\n"
"func fill(a)\n"
"  local b, i\n"
"\n"
"  dim b(16)\n"
"  for i=0 to 16\n"
"    b(i)=16-a(i)\n"
"  next\n"
"  fill=b\n"
"end\n"
"\n"
"DIM v(4)\n"
"v=fill(v)\n"
"\n"
"\n"
">> The pseudo-operators ++, -- and p=\n"
"_______________________________________________________________________\n"
"\n"
"The ++ and -- operators are used to increase or decrease the value of a\n"
"variable by 1.\n"
"\n"
"Example:\n"
"\n"
"x = 4\n"
"x ++ : REM x <- x + 1 = 5\n"
"x -- : REM x <- x - 1 = 4\n"
"\n"
"The generic p= operators are used as in C\n"
"Where p any character of -+/\\*^%&|\n"
"\n"
"x += 4 : REM x <- x + 4\n"
"x *= 4 : REM x <- x * 4\n"
"\n"
"All these pseudo-operators are not allowed inside of expressions\n"
"y = x ++ ' ERROR\n"
"z = (y+=4)+5 ' ALSO ERROR\n"
"\n"
"\n"
"${key:use}\n"
">> The USE keyword\n"
"_______________________________________________________________________\n"
"\n"
"This keyword is used on specific commands to passing a user-defined\n"
"expression.\n"
"\n"
"SPLIT s,\" \",v USE TRIM(x)\n"
"\n"
"In that example, every element of V() will be 'trimmed'.\n"
"\n"
"Use the x variable to specify the parameter of the expression.\n"
"If the expression needs more parameter, you can use also the names\n"
"y and z\n"
"\n"
"\n"
"${key:do}\n"
">> The DO keyword\n"
"_______________________________________________________________________\n"
"\n"
"This keyword is used to declare single-line commands.\n"
"It can be used with WHILE and FOR-family commands.\n"
"\n"
"Example:\n"
"\n"
"FOR f IN files(\"*.txt\") DO PRINT f\n"
"\n"
"WHILE i < 4 DO i ++\n"
"\n"
"Also, it can be used by IF command (instead of THEN), but is not\n"
"suggested.\n"
"\n"
"\n"
">> Uncategorized\n"
"_______________________________________________________________________\n"
"\n"
"* White-spaces\n"
"\n"
"The white-spaces in the SmallBASIC and in \"C\" are:\n"
"space, form-feed ('\\f'), new-line  ('\\n'), carriage-return ('\\r'),\n"
"horizontal-tab ('\\t'), and vertical tab ('\\v').\n"
"\n"
"The 'white-spaces' are used by routines like SQUEEZE.\n"
"\n"
"* The '$' is an unused character. You can use it as suffix to\n"
"functions names. SB will ignore it.\n"
"\n"
"Example:\n"
"x=LEFT(\"abcd\", 2)\n"
"y=LEFT$(\"abcd\",2)\n"
"\n"
"Both calls are correct and are the same.\n"
"\n"
"* Notes on FOR-commands\n"
"\n"
"These commands are evaluate the 'destination' everytime.\n"
"\n"
"Example:\n"
"\n"
"FOR i=0 TO LEN(FILES(\"*.txt\"))-1\n"
"    PRINT i\n"
"NEXT\n"
"\n"
"In that example the 'destination' is the LEN(FILES(\"*.txt\"))-1\n"
"For each value of i the destination will be evaluated.\n"
"That is WRONG but it is supported by BASIC and many other languages.\n"
"\n"
"So, it is much better to be rewritten as\n"
"\n"
"idest=LEN(FILES(\"*.txt\"))-1\n"
"FOR i=0 TO idest\n"
"    PRINT i\n"
"NEXT\n"
"\n"
"Of course, it is much faster too.\n"
"\n"
"_______________________________________________________________________\n"
"\n"
;