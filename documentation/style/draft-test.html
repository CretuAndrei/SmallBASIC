<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN
		"http://www.w3.org/TR/html4/loose.dtd"">
<html>
<head>
  <title>MacroCosmos</title>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-7">
  <META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
  <LINK REL="STYLESHEET" HREF="draft.css">
</head>

<body>

<!-- Header -->

<div class="head">
<img src="sbdoc.png">
<h1 id="pagetitle">MacroCosmos</h1>
<h2 id="pagesubtitle">Working Draft, 1 Αυγούστου 2003</h2>

<dl>
<dt>Συγγραφείς</dt>
<dd><a href="mailto:nereus@freemail.gr">Νικόλαος Χριστόπουλος</a></dd>
<dt>Έκδοση 0.1</dt>
<dd>1/8/2003, <a href="mailto:nereus@freemail.gr">Νικόλαος Χριστόπουλος</a></dd>
</dl>

<p class="copyright">
Copyright &copy; 2003 <b>MacroCosmos</b> project. All rights reserved.
</p>

</div>
<hr size=1 noshade>

<!-- Pre -->

<h2 id="abstract">
Περίληψη
</h2>

<p>
Αυτό το έγγραφο περιγράφει το έργο 'MacroCosmos'.
Πρόκειται για το πρότυπο αυτού του έργου.
Το έργο MacroCosmos περιλαμβάνει μια γλώσσα προγραμματισμού, και ένα σύνολο από προκαθορισμένα αρχεία ορισμών.
Η γλώσσα αυτή έχει σκοπό να αυτοκαθορίζεται ανάλογα τις απαιτήσεις του χρήστη κατά την διάρκεια της εκτέλεσης της.
</p>

<hr size=1 noshade>

<!-- INDEX -->
<div class="toc">
<h2 id="toc">Ευρετήριο</h2>

<ol>
<li><a href="#erg">Γιατί χρειαζόμαστε ένα νέο εργαλείο</a></li>
<li><a href="#trg">Στόχοι του έργου</a></li>
<li><a href="#prb">Προβλήματα των υπάρχοντων εργαλείων</a></li>
<li><a href="#idea">Προδιαγραφές</a></li>
	<ol>
	<li><a href="#mac">Μάκρο</a></li>
	<li><a href="#remac">Μάκρο και regular expressions</a></li>
	<li><a href="#code">Κώδικας</a></li>
	<li><a href="#mcc">Μάκρο-κώδικας!</a></li>
	<li><a href="#cme">Άλλες εντολές</a></li>
	<li><a href="#syse">Μεταβλητές συστήματος</a></li>
	<li><a href="#mm">Μακρο-βιότης</a></li>
	<li><a href="#mc">Μακρο-κοσμος</a></li>
	<li><a href="#mmm">Μακρο-Μικρό-Μεγά-κοσμος</a></li>
	</ol>
</ol>

</div>

<hr size=1 noshade>

<!-- CHAP 1 -->
<a name="erg"><h2>Γιατί χρειαζόμαστε ένα νέο εργαλείο</h2></a>

<p>
Πολλές φορές έχουμε προσέξει πόσο παρόμοια είναι διάφορα κείμενα και κώδικες,
είτε αυτά είναι document markup languages, είτε γλώσσες προγραμματισμού.
</p>

<center>
<table class="latex" cellpadding="8" width="80%">
<caption align="bottom">Παράδειγμα σε document markup languages</caption>
<tr><td>LaTeX   </td><td><samp>\chapter{Τίτλος κεφάλαιο}</samp></td></tr>
<tr><td>DocBook </td><td><samp>&lt;chapter&gt;Τίτλος κεφάλαιο&lt;/chapter&gt;</samp></td></tr>
<tr><td>HTML    </td><td><samp>&lt;h1&gt;Τίτλος κεφάλαιο&lt;/h1&gt;</samp></td></tr>
</table>
</center>

<p>&nbsp;</p>

<center>
<table class="latex" cellpadding="8" width="80%">
<caption align="bottom">Παράδειγμα σε γλώσσες προγραμματισμού</caption>
<tr><td>BASIC          </td><td><samp>FOR i=1 TO 6 STEP 2</samp></td></tr>
<tr><td>C/C++/Java/etc </td><td><samp>for ( i = 1; i <= 6; i += 2 )</samp></td></tr>
<tr><td>x86 Assembly   </td><td><samp>mov cx, 1<br>@loop:<br>...<br>add cx, 2<br>cmp cx, 6<br>jle loop</samp></td></tr>
</table>
</center>

<p>
Εκτός από τα παραπάνω, μάκρος για την απλούστευση της συγγραφής κειμένου ή κώδικα είναι απαραίτητα,
πράγμα που δεν υποστηρίζεται απο πολλά εργαλεία, σε άλλα είναι μειωμένων δυνατοτήτων και σε άλλα
δυσκολόχρηστα. Ποιός δεν θα ήθελε να έχει ένα preprocessor για HTML; Το TeX έχει macros αλλά ποιός
δεν θα προτιμούσε κάτι πιο συνηθισμένο σαν της C ή αν είναι συνηθισμένος σε TeX τότε TeX macros σε HTML;
</p>

<!-- CHAP 2 -->
<a name="trg"><h2>Στόχοι του έργου</h2></a>

<p>
Η ιδέα του macrocosmos έχει ως στόχους:
</p>

<ol type=i>
<li>Ο κάθε χρήστης να χρησιμοποιεί το συντακτικό που προτιμά για να γράψει ένα έγγραφο ή κώδικα</li>

<li>Ο κάθε χρήστης να επεκτίνει το συντακτικό που προτιμά κατά την κρίση του χωρίς να χρειάζεται
γι' αυτό να περιορίζεται σε κάποιο πρότυπο ή στα όριο του προϊόντος που στοχεύει το έγγραφο/κώδικας</li>

<li>Από το αρχικό έγγραφο/κώδικα να βγαίνει αποτέλεσμα σε όλα τα υποστηριζόμενα αποτελέσματα</li>

<li>Με δύο αρχεία ορισμών να μπορεί να γίνετε μετατροπή από την μια μορφή σε μια άλλή, είτε αυτή
είναι μια ήδη υπάρχουσα είτε αυτή είναι ένα συντακτικό που προκαθορίστηκε</li>

<li>Να μην υπάρχει κανένας περιορισμός συμβόλων. Δηλαδή όλα τα σύμβολα που θα χρησιμοποιηθούν
να μπορούν να επανακαθοριστούν</li>

<li>Το συντακτικό θα πρέπει να είναι ευκολονόητο και δυναμικό,
έτσι ώστε να μπορεί να αλλάξει απο τον χρήστη εύκολα</li>

</ol>

<p>
Εάν αυτοί οι στόχοι πραγματοποιηθούν, ο χρήστης θα μπορεί - μεταξύ των άλλων - να κάνει με
εύκολο τρόπο τα παρακάτω:
</p>

<ul>
<li>Να γράφει ένα κείμενο στο συντακτικό που προτιμά (ή επεκταμένο ανάλογα την περίπτωση)
και αυτό να μετατρέπεται με σωστό και δομημένο τρόπο, σε
LaTeX, TeX, TexInfo,
*roff,
HTML, XML, SGML,
RTF, plain text, POD, BB-Code,
PDF, DVI, PNG, BMP, C (data), BASIC (data), PASCAL (data),
κ.λπ.</li>

<li>Να φτιάχνει ψευδο-compilers με έξοδο στην γλώσσα της αρέσκιας του είτε αυτή λέγετε Assembly,
είτε Pascal, είτε απ' ευθείας machine language. Έτσι για παράδειγμα θα μπορεί να γράφει shell
scripts με εντολές BASIC τα οποία θα μετατρέπονται σε εντολές bash και τέλος θα εκτελούνται</li>

<li>Να φτιάχνει ψευδο-compilers με έξοδο υψηλότερου επιπέδου αποτελέσματα π.χ. απο Assembly σε C
βασιζόμενο στις επαναλήψεις του κώδικα ή σε δυναμικά συνδεόμενο κώδικα που θα έχει φτιάξει σε
άλλη γλώσσα</li>

<li>Να φτιάχνει documentation στο source code χρησιμοποιόντας συντακτικό της αρέσκειας του.
Δηλαδή μπορεί να γράφει τα σχόλια σε javadoc συντακτικό αλλά να πάρει το αποτέλεσμα και σε
doxygen</li>

</ul>

<!-- CHAP 3 -->
<a name="prb"><h2>Προβλήματα των υπάρχοντων εργαλείων</h2></a>

<p>
Τα περισσότερα από αυτά που αναφέρω, υπάρχουν σε ξεχωριστά πακέτα, π.χ. xml->latex, yacc/lex κ.λπ.
Τα προβλήματα που έχουν τα ήδη έτοιμα πακέτα έχουν ως εξής:
</p>

<ol>

<li>Κάθε ένα παρ' ότι μπορεί να κάνει παρόμοια δουλειά με ένα άλλο έχει διαφορετικό συντακτικό.
Αυτό απαιτεί τελικά από τον χρήστη, αρκετό ανούσιο χρόνο, ώστε να μάθει το συντατικό αυτών</li>

<li>Πολλά απο αυτά είναι φτιαγμένα σε γλώσσα προγραμματισμού που για πολλούς χρήστες αυτό
είναι μεγάλο πρόβλημα είτε γιατί δεν έχουν σκοπό να μάθουν την συγκεκριμένη γλώσσα για
να διορθώσουν ένα μικροπρόβλημα (π.χ. lisp) είτε γιατί πρέπει να ασχοληθούν με χιλιάδες γραμμές
C κώδικα, είτε γιατί είναι απλοί χρήστες και δεν έχουν ιδέα από προγραμματισμό</li>

<li>Όλα αυτά τα εργαλεία είναι φτιαγμένα το καθένα σε ότι βόλευε τον προγραμματιστή τους με
αποτέλεσμα να έχουμε μια "παρδαλή" συλλογή όπου απαιτούνται υπερβολικά πολλές και άχρηστες
γνώσεις για την χρήση και την ρύθμιση του κάθε ενός απο αυτά</li>

<li>Σχεδόν σε όλες τις περιπτώσεις η επέκταση ή η προσαρμογή στις επιλογές του χρήστη
ένος τέτοιου εργαλείου, χρειάζεται γνώσεις του κώδικα του, ο οποίος μπορεί να υπερβαίνει
κατά πολύ τις μερικές χιλιάδες γραμμές, ή κάποιας γλώσσας η οποία είναι είτε δυσκολονόητη
είτε απλά μη αρεστή στο χρήστη, είτε ο χρήστης να μην είναι προγραμματιστής, είτε αυτό
να είναι αδύνατο λόγο σχεδιασμού
</li>

<li>Συνήθως αυτά τα εργαλεία λειτουργούν αποκλειστικά για από ή/και προς αποκλειστικά
συγκεκριμένες μορφές, πράγμα που καθιστά την εργασία που έχει ήδη γίνει ουσιαστικά μην
επαναχρησιμοποιήσιμη. Έτσι για παράδειγμα ένα πρόγραμμα που μετατρέπει απο TeX σε HTML
παρ' ότι έχει ήδη έτοιμο τον κώδικα για την επεξεργασία των TeX αρχείων, αυτός ο κώδικας
ουσιαστικά δεν μπορεί να χρησιμοποιηθεί (ή απλά είναι χρονοβόρα και πολύπλοκη η διαδικασία
να μεταφερθεί σε άλλο έργο) για την παραγωγή SGML αρχείων.
</li>

</ol>

<!-- CHAP 4 -->
<a name="idea"><h2>Προδιαγραφές</h2></a>
<p>
Όλα τα σύμβολα μπορούν να επανακαθορίζονται, αυτό θα γίνετε με αντίστοιχη εντολή.
Πρέπει όμως να υπάρχουν τα προκαθορισμένα.
</p>

<p>
Βασικά προκαθορισμένα σύμβολα,
'<tt>@</tt>' εντολές μακρόκοσμου.
</p>

<p>
Μέσα στα τμήματα κώδικα του macrocosmos, δηλαδή τμήματα που έχουν δηλωθεί με
κάποια εντολή '@-κάτι' ισχύουν τα παρακάτω σύμβολα,
'<tt>\</tt>' ειδικός χαρακτήρας,
'<tt>${x}</tt>' η τιμή της μεταβλητής x.
</p>

<!-- CHAP 4.1 -->
<a name="mac"><h3>Macros</h3></a>

<p>
Τα macros είναι το πιο βασικό τμήμα του έργου αυτού.
</p>

<pre class="example">
@macro &lt;h1&gt
\\chapter{
@eom

@macro &lt;/h1&gt
@eom
</pre>

<p>
Στο παραπάνω παράδειγμα δηλώνουμε δύο macros. Το πρώτο λέγετε &lt;h1&gt;. Το όνομα των μάκρο
μπορεί να είναι οποιαδήποτε σειρά χαρακτήρων πλην των '<tt>{</tt>' και '<tt>\n</tt>'. Αλλά και
αυτά θα πρέπει να μπορούν να χρησιμοποιηθούν με την χρήση του ειδικού χαρακτήρα '<tt>\</tt>'.
</p>

<p>
Το σύμβολο '<tt>{</tt>' δηλώνει την αρχή των παραμέτρων. Ο χαρακτήρας '<tt>;</tt>'
διαχωρίζει τις παραμέτρους και το σύμβολο '<tt>}</tt>', το τέλος αυτών. Οι μεταβλητές
μέσα στο μάκρο πρέπει να δηλώνονται με το '<tt>$</tt>' όπου πρέπει να ακολουθεί ένα τμήμα με
το όνομα της μεταβλητής '<tt>{x}</tt>'.
</p>

<pre class=example>
@macro chap{x}
\\chapter{${x}}
@eom
</pre>

<p>
Επίσης θα πρέπει να είναι ικανό να δηλώσουμε και το τέλος του
κειμένου.
</p>

<pre class="example">
@macro &lt;h1&gt{x}&lt;/h1&gt;
\\chapter{${x}}
@eom
</pre>

<p>
Αν ο ορισμός του μάκρο γίνετε χωρίς ορισμό τέλους, τότε η
αντικατάσταση πρέπει να γίνει όταν έχουν πλήρη ορισμό στο κείμενο
π.χ. '<samp>chap{Ένας τίτλος}</samp>'. Στην περίπτωση που ορίζεται
το τέλος του μάκρο τότε θα πρέπει να αντικαταστήσουμε το κείμενο
που περικλείεται στον ορισμό π.χ. '<samp>&lt;h1&gt;Ένας Τίτλος&lt;/h1&gt;</samp>'.
Παρατηρούμε δηλαδή ότι στην πρώτη περίπτωση η χρήση των '<tt>{}</tt>' απαιτήται ενώ στην
δεύτερη όχι. Στην περίπτωση που δεν έχουμε παράμετρους τα '<tt>{}</tt>' είναι άχρηστα.
</p>

<pre class=example>
@macro chap{x}
\\chapter{${x}}
@eom
@macro &lt;h1&gt{x}&lt;/h1&gt;
\\chapter{${x}}
@eom

&lt;h1&gt;Chapter #1&lt;/h1&gt;
chap{Chapter #2}
</pre>

<p>Αποτέλεσμα</p>
<pre class="result">

\chapter{Chapter #1}
\chapter{Chapter #2}
</pre>

<p>
Η εκτέλεση των μάκρο πρέπει να γίνετε αμέσως μετά τον ορισμό (δηλαδή από το '<tt>@eom</tt>') και
μόνο στο παρακάτω κείμενο. Έτσι έχουμε την δυνατότητα να φτιάχνουμε πιο σύνθετα μάκρος.
</p>

<pre class=example>
@macro X
1/(1-SQR(1/(c-a)))
@eom

@macro Y
z = m/g * (X)/3
@eom

Y
</pre>

<pre class=result>

z = m/g * (1/(1-SQR(1/(c-a))))/3
</pre>

<p>
Εναλακτικά το όνομα του μάκρο πρέπει να δηλώνετε σε 3 μέρη. Το κάθε μέρος δηλώνετε ως
τμήμα που περικλείεται απο τα '<tt>{}</tt>'.
</p>

<pre class=example>
@macro {&lt;h1&gt;}{x}{&lt;/h1&gt;}
...
@eom
</pre>


<!-- CHAP 4.2 -->
<a name="remac"><h3>Macros και regular expressions</h3></a>

<p>
Όπως είδαμε μπορούμε να ορίσουμε μάκρος τα οποία ορίζονται
απο την αρχή και απο το τέλος του κειμένου. Αυτό πρέπει
να μπορούμε να το κάνουμε και με regular expressions.
</p>

<pre class="example">
@remac {[A-Za-z0-9_]+}{x}{\n}
...
@eom
</pre>

<p>
Τίθετε όμως το εξής πρόβλημα. Ενώ μέχρι τώρα το πρώτο και τελευταίο
μέρος του κειμένου αντικαθήστατο απο τα περιεχόμενα του μάκρο,
αυτή την φορά μπορεί να θέλουμε να αντικατασταθεί μόνο το εσωτερικό
κείμενο διότι το expression μπορεί να αναφέρει μεγάλο μέρος του
κειμένου που θέλουμε να παραμείνει απείραχτο.
</p>

<pre class=example>
@iremac {[A-Za-z0-9_]+}{x}{\n}
...
@eom
</pre>

<!-- CHAP 4.3 -->
<a name="code"><h3>Code</h3></a>

<p>
Εκτός τα μάκρος πρέπει να έχουμε και μια βασική συλλογή από δυνατότητες.
Όπως, μεταβλητές, εντολές επαναλήψεων, συναρτήσεις κ.α. Αυτές πρέπει
να δηλώνονται μέσα σε τμήματα που ορίζονται απο τις εντολές '<tt>@code</tt>'
και '<tt>@eoc</tt>'.
</p>

<p>
Το 'code' πρέπει να έχει την δυνατότητα να δουλέψει με ότι γλώσσα
θέλει ο χρήστης π.χ. perl, php, κ.λπ.
</p>

<pre class=example>
...
@code{perl}
print 1;
@eoc
</pre>

<p>
Αυτό είναι εύκολο, αρκεί να μπορούμε να έχουμε και μια επικοινωνία.
Στο <tt>stdin</tt> του κώδικα πρέπει να στέλνουμε το κείμενο που ακολουθεί
το @eoc ενώ στο <tt>stdout</tt> επιστρέφει το επεξεργασμένο κείμενο, το οποίο
για τον macrocosmo είναι η συνέχεια του κειμένου.
</p>

<p>
Πέρα απο τον default τρόπο πρέπει να έχουμε την δυνατότητα να μεταφέρουμε
κείμενα απο και προς μεταβλητές. Αυτό θα πρέπει να γίνετε με τα &lt; και
&gt;.
</p>

<pre class=example>
...
@code{sbasic<${x}>${y}}
lninput stdin_str
print "Είμαι το y και αυτή είναι η τιμή του χ", stdin_str
@eoc
...
</pre>

<p>
Πολλές φορές είναι πιο εύκολο για εμάς να ορίζουμε τις μεταβλητές
με απλή αντικατάσταση αντί να τα μεταφέρουμε μεσω stdin/out.
</p>

<pre class=example>
...
@code{sbasic>${y}}
print "Είμαι το y και αυτή είναι η τιμή του χ", ${x}
@eoc
...
@echo{${y}}
</pre>


<!-- CHAP 4.4 -->
<a name="mcc"><h3>Μάκρο-κώδικας!</h3></a>

<p>
Συνήθως ως μακρο-κώδικα εννοούμε κάτι το τελείως διαφορετικό
από ότι χρειάζεται τώρα να δηλώσουμε, την μίξη κώδικα και μάκρο.
</p>

<pre class="example">
@macro chap{x}
@code{php&lt;${x}}
...
@eoc
@eom
</pre>

<p>
Σ' αυτή την περίπτωση ο κώδικας πρέπει να εκτελείτε σε κάθε σημείο που
το μάκρο αντικαταστεί το κείμενο. Ο κώδικας αυτός έχει επαφή μόνο με
τα δεδομένα του αντίστοιχου μάκρο και όχι ολόκληρου του κείμενου.
Το αποτέλεσμα του κώδικα είναι και ο κώδικας του μάκρο.
</p>

<pre class="example">
@macro chap{x}
@code{php}
echo "\\chapter{${x}}\n";
@eoc
@eom

chap{x}
</pre>

<!-- CHAP 4.5 -->
<a name="cme"><h3>Άλλες εντολές</h3></a>

<p>
</p>

<dl>
<dt>@echo</dt>
<dd>Τυπώνει τις παραμέτρους του</dd>
<dt>@set</dt>
<dd>Ορίζει τιμή σε μια μεταβλητή</dd>
<dt>@push</dt>
<dd>Αποθηκεύει μια μεταβλητή στη stack</dd>
<dt>@pop</dt>
<dd>Επαναφέρει μια μεταβλητή από τη stack</dd>
<dt>@store</dt>
<dd>Αποθηκεύει μια μεταβλητή σε μια λίστα</dd>
<dt>@printlist</dt>
<dd>Τυπώνει μια λίστα</dd>
<dt>@conf</dt>
<dd>Ορίζει την τιμή σε μια μεταβλητή συστήματος του macrocosmos</dd>
</dl>

<!-- CHAP 4.6 -->
<a name="syse"><h3>Μεταβλητές συστήματος</h3></a>

<p>
</p>

<dl>
<dt>case</dt>
<dd>Για case != 0 τότε οι συγκρίσεις των string γίνονται με ignore case</dd>
<dt>symbols</dt>
<dd>Επανακαθορισμός των συμβόλων</dd>
</dl>

<!-- CHAP 4.7 -->
<a name="mm"><h3>Μακρο-βιότης - Μικρό μακρό-κοσμος</h3></a>

<p>
TODO: Περιγραφή των μάκρο rules, classes και subclasses. Αντίστοιχα
και macros σε μεταβλητές με visibility μόνο στο parent macro.
</p>

<pre class=example>
@rule{&lt;!--; --&gt;; comment}
@rule{&lt;head&gt;; &lt;/head&gt;; header}
@rule{&lt;body*&gt;; &lt;/body&gt;; body}

@macro.comment{text}
Αυτό εδώ είναι comment χωρίς class-γονέα
@eom

@macro.header.comment{text}
Αυτό εδώ είναι comment του header
@eom

@macro.body.comment{text}
Αυτό εδώ είναι comment του body
&lt;&lt;EOF
@macro X
...και αυτό εδώ μάκρο με κύκλο ζωής μέσα στο parent macro...
@eom

${text}
EOF

Αλλά θα έπρεπε να γράφετε και έτσι
@macro {X}{x}{}
...και αυτό εδώ, επίσης, μάκρο με κύκλο ζωής μέσα στο parent macro...
@eom
@eom
</pre>

<!-- CHAP 4.8 -->
<a name="mc"><h3>Μακρο-κοσμος</h3></a>

<p>
TODO: Περιγραφή των πακέτων και του κύκλου ζωής τους,
εκτέλεση μακρο-πακέτου ανά class ή subclass, επαναφορά και μίξη
</p>

<pre class="example">
@include...
@require...
@import...
@exclude...
@revert...
</pre>

<!-- CHAP 4.9 -->
<a name="mmm"><h3>Μακρο-Μικρό-Μεγά-κοσμος</h3></a>

<p>
TODO: Περιγραφή σύνθετης δομής, εκεί όπου ο πρώην μακρόκοσμος
είναι μικρο-κοσμος. Με απλά λόγια όλα τα προηγούμενα πως
θα λειτουργούν ως καθορισμένο υποσύνολο ενος νέου πακέτου.
</p>

<pre class=example>
@import "html2latex.mcs" as html
@import "latex2pod.mcs" as latex

@macro {&lt;html&gt;}{x}{&lt;/html&gt;}
html{&lt;${x}&gt;${y}}
latex{&lt;${y}&gt;${z}}
${z}
@eom

</pre>

<!-- EOF -->

</body>
</html>
